{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-0b31cc7a9533cb0f477b42af3bba121444b80876",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/MultiCrowdFund.sol": "project/contracts/MultiCrowdFund.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/MultiCrowdFund.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.0;\r\n \r\n/// @title CrowdFundMulti (multi-campaign, pull refunds, liveBalance tracked)\r\n/// @notice Create many campaigns; donations allowed until deadline; owner withdraws on success after deadline; contributors self-claim refunds on failure.\r\ncontract MultiCrowdFund {\r\n    struct Campaign {\r\n        address owner;\r\n        string title;       // human-friendly\r\n        uint goal;          // in wei\r\n        uint deadline;      // unix time (seconds)\r\n        uint totalRaised;   // lifetime sum (does NOT go down)\r\n        uint liveBalance;   // withdrawable/refundable amount for this campaign\r\n        bool goalReached;   // flips as soon as totalRaised >= goal\r\n        bool fundsWithdrawn;\r\n    }\r\n \r\n    mapping(uint => Campaign) public campaigns;\r\n    mapping(uint => mapping(address => uint)) public contributions; // campaignId -> donor -> amount\r\n    uint public nextCampaignId;\r\n    bool private _locked; // reentrancy guard\r\n \r\n    event CampaignCreated(uint indexed id, address indexed owner, string title, uint goal, uint deadline);\r\n    event Donated(uint indexed id, address indexed from, uint amount, uint newTotal, uint liveBalance);\r\n    event GoalReached(uint indexed id, uint amount);\r\n    event FundsWithdrawn(uint indexed id, address indexed owner, uint amount);\r\n    event Refunded(uint indexed id, address indexed to, uint amount);\r\n \r\n    modifier nonReentrant() {\r\n        require(!_locked, \"Reentrancy\");\r\n        _locked = true;\r\n        _;\r\n        _locked = false;\r\n    }\r\n    modifier campaignExists(uint id) {\r\n        require(campaigns[id].owner != address(0), \"No campaign\");\r\n        _;\r\n    }\r\n    modifier onlyOwner(uint id) {\r\n        require(msg.sender == campaigns[id].owner, \"Not owner\");\r\n        _;\r\n    }\r\n \r\n    /// @notice Create campaign; `_goal` is in wei; `_durationMinutes` in minutes\r\n    function createCampaign(string memory _title, uint _goal, uint _durationMinutes)\r\n        external\r\n        returns (uint id)\r\n    {\r\n        require(bytes(_title).length != 0, \"Title required\");\r\n        require(_goal > 0, \"Goal > 0\");\r\n        require(_durationMinutes > 0, \"Duration > 0\");\r\n \r\n        id = nextCampaignId++;\r\n        uint dl = block.timestamp + _durationMinutes * 60;\r\n \r\n        campaigns[id] = Campaign({\r\n            owner: msg.sender,\r\n            title: _title,\r\n            goal: _goal,\r\n            deadline: dl,\r\n            totalRaised: 0,\r\n            liveBalance: 0,\r\n            goalReached: false,\r\n            fundsWithdrawn: false\r\n        });\r\n \r\n        emit CampaignCreated(id, msg.sender, _title, _goal, dl);\r\n    }\r\n \r\n    /// @notice Donate ETH to a specific campaign while active (donations continue even after goal until deadline)\r\n    function donateTo(uint id) external payable campaignExists(id) {\r\n        require(msg.value > 0, \"No ETH\");\r\n        Campaign storage c = campaigns[id];\r\n        require(block.timestamp < c.deadline && !c.fundsWithdrawn, \"Campaign ended\");\r\n \r\n        contributions[id][msg.sender] += msg.value;\r\n        c.totalRaised += msg.value;\r\n        c.liveBalance += msg.value;\r\n \r\n        if (!c.goalReached && c.totalRaised >= c.goal) {\r\n            c.goalReached = true;\r\n            emit GoalReached(id, c.totalRaised);\r\n        }\r\n \r\n        emit Donated(id, msg.sender, msg.value, c.totalRaised, c.liveBalance);\r\n    }\r\n \r\n    /// @notice Owner withdraws all liveBalance for a successful campaign after deadline\r\n    function withdrawFunds(uint id) external campaignExists(id) onlyOwner(id) nonReentrant {\r\n        Campaign storage c = campaigns[id];\r\n        require(block.timestamp >= c.deadline, \"Too early\");\r\n        require(c.goalReached, \"Goal not reached\");\r\n        require(!c.fundsWithdrawn, \"Already withdrawn\");\r\n \r\n        uint amount = c.liveBalance;\r\n        require(amount > 0, \"Nothing to withdraw\");\r\n \r\n        c.fundsWithdrawn = true;     // effects first\r\n        c.liveBalance = 0;\r\n \r\n        (bool ok, ) = payable(c.owner).call{value: amount}(\"\");\r\n        require(ok, \"Transfer failed\");\r\n \r\n        emit FundsWithdrawn(id, c.owner, amount);\r\n    }\r\n \r\n    /// @notice Refund callerâ€™s contribution if campaign failed after deadline\r\n    function refund(uint id) external campaignExists(id) nonReentrant {\r\n        Campaign storage c = campaigns[id];\r\n        require(block.timestamp >= c.deadline, \"Too early\");\r\n        require(!c.goalReached, \"Campaign succeeded\");\r\n \r\n        uint bal = contributions[id][msg.sender];\r\n        require(bal > 0, \"Nothing to refund\");\r\n \r\n        contributions[id][msg.sender] = 0; // effects\r\n        c.liveBalance -= bal;\r\n \r\n        (bool ok, ) = payable(msg.sender).call{value: bal}(\"\");\r\n        require(ok, \"Refund failed\");\r\n \r\n        emit Refunded(id, msg.sender, bal);\r\n    }\r\n \r\n    // --- Convenience views ---\r\n    function getTimeLeft(uint id) external view campaignExists(id) returns (uint) {\r\n        Campaign storage c = campaigns[id];\r\n        if (block.timestamp >= c.deadline) return 0;\r\n        return c.deadline - block.timestamp;\r\n    }\r\n \r\n    function getCampaignBalance(uint id) external view campaignExists(id) returns (uint) {\r\n        return campaigns[id].liveBalance;\r\n    }\r\n \r\n    // Block accidental direct sends\r\n    receive() external payable { revert(\"Use donateTo\"); }\r\n    fallback() external payable { revert(\"Use donateTo\"); }\r\n}\r\n "
      }
    }
  }
}